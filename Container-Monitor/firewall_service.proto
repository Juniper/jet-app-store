/* 
 * This file defines the ACL package for JUNOS. 
 *
 * Brief Description of the key concepts associated with this package and functionality is
 * as follows:
 *
 * ACL is an acronym to Access List which is a basic stateless forwarding construct to match 
 * on packet content and take a set of actions if packet passes the matching criteria.
 *
 * An ACL is made up of a ordered set of ACL Entries, which defines how a packet is matched
 * against configured criteria and be treated.
 *
 * Each ACL Entry or ACE defines a set of packet matching criteria and a set of action to take 
 * on the packet if the matching criteria is true. A packets needs to match ALL the matches in 
 * an ACE to be considered a match.
 *
 * A Match is defined by an operation, packet field and value to be matched against. For details
 * on the operations supported and various packet fields that could be matched, refer the 
 * corresponding Enum/Message structure below.
 * 
 * An action determines what to do with the packet on meeting the matching criteria. There are two
 * types of actions, viz. terminating and non-terminating. Each ACE can have zero or more  
 * non-terminating actions and zero or exactly one terminating action. A non-terminating action is 
 * one that does not stop the packet to undergo the rest of the ACL processing. An terminating action 
 * is one, that stops the packet to undergo any further ACL processing. 
 *
 * An attachment point or a bind point is the point in path of packet processing where the packet is
 * subjected to ACL processing. An attachment point is defined by attachment entity and direction in 
 * which the ACL is applied. For eg. a typical bind point is an interface where a packet is subjected 
 * to ACL.
 *
 * Diagram below depicts an object diagram for a typical ACL.
 * Legends:
 *           ACE-1 is the ordered Access List Entry at position 1.
 *           ACE-n is the ordered Access List Entry at position n.
 *             M-n is the match number n in list of matching criteria in a given ACE.
 *             A-n is the action number n in the list of actions for a given ACE.
 *                    No no more than 1 action could be a terminating action.
 *    
 *        +-------+-------+-----+------+ 
 * ACL -> | ACE-1 | ACE-2 | ... | ACE-n|
 *        +-------+-------+-----+------+ 
 *            | 
 *            | 
 *            |      +-----+
 *            +----->| M-1 |
 *                   +-----+
 *                   | M-2 |
 *                   +-----+
 *                   | ... |
 *                   +-----+
 *                   | M-n |
 *                   +-----+
 *                      |
 *                      |           +-----+
 *                      +---------->| A-1 |
 *                                  +-----+
 *                                  | A-2 |
 *                                  +-----+
 *                                  | ... |
 *                                  +-----+
 *                                  | A-n |
 *                                  +-----+
 *
 */


syntax = "proto3";
import "jnx_addr.proto";

package acl;

/*
 *  Boolean types 
 */

enum AclBooleanType {

    ACL_FALSE = 0;
    ACL_TRUE = 1;
}

/*
 *  Supported Match Operations
 */

enum AclMatchOperation {

    ACL_MATCH_OP_INVALID = 0;
    ACL_MATCH_OP_EQUAL = 1;
    ACL_MATCH_OP_NOT_EQUAL = 2;
}

/*
 *  Various ACL Policer Type
 */

enum AclPolicerType {

    // Invalid policer type
    ACL_POLICER_INVALID = 0;

    // Single rate two color
    ACL_TWO_COLOR_POLICER = 1;

    // Singel rate three color
    ACL_SINGLE_RATE_THREE_COLOR_POLICER = 2;

    // Two rate three color
    ACL_TWO_RATE_THREE_COLOR_POLICER = 3;

    // Hierarchical 
    ACL_HIERARCHICAL_POLICER = 4;
}

/*
 * Policer Flags
 */

enum AclPolicerFlags {

    ACL_POLICER_FLAG_INVALID = 0;
 
    // The policer instance is activated for each ACE its referenced.
    ACL_POLICER_FLAG_TERM_SPECIFIC = 1; 

    // The policer instance is activated at global ACL level.
    ACL_POLICER_FLAG_FILTER_SPECIFIC = 2;
}

/*
 * Policer Rate unit
 */

enum AclPolicerRate {

    ACL_POLICER_RATE_INVALID = 0;

    // Bits per second
    ACL_POLICER_RATE_BPS = 1;
       
    // Kilobits per second
    ACL_POLICER_RATE_KBPS = 2;

    // Megabits per second
    ACL_POLICER_RATE_MBPS = 3;

    // Gigabits per second
    ACL_POLICER_RATE_GBPS = 4;
}

/*
 * Policer Burst Size
 */

enum AclPolicerBurstSize {
   
    ACL_POLICER_BURST_SIZE_INVALID = 0;

    // Bytes
    ACL_POLICER_BURST_SIZE_BYTE = 1;

    // KiloBytes
    ACL_POLICER_BURST_SIZE_KBYTE = 2;

    // MegaBytes
    ACL_POLICER_BURST_SIZE_MBYTE = 3;

    // GigaBytes
    ACL_POLICER_BURST_SIZE_GBYTE = 4;
}

/*
 * Color mode for SRTCM and TRTCM
 */

enum AclColorModeType {

    ACL_COLOR_MODE_INVALID = 0;

    //Color Blind
    ACL_COLOR_MODE_COLOR_BLIND = 1;

    //Color Aware
    ACL_COLOR_MODE_COLOR_AWARE = 2;
}

/*
 * Loss Priority
 */

enum AclLossPriority {

    ACL_LOSS_PRIORITY_INVALID = 0;

    ACL_LOSS_PRIORITY_HIGH = 1;

    ACL_LOSS_PRIORITY_MEDIUM_HIGH = 2;

    ACL_LOSS_PRIORITY_MEDIUM_LOW = 3;

    ACL_LOSS_PRIORITY_LOW = 4;
}


/*
 * Various Reject Action Reasons.
 */

enum AclEntryActionRejectReason {

    // Send ICMP Administratively Prohibited message
    ACL_ACTION_REJECT_ADMINISTRATIVELY_PROHIBITED = 0;

    // Send ICMP Bad Host ToS message 
    ACL_ACTION_REJECT_BAD_HOST_TOS = 1;

    // Send ICMP Bad Network ToS message 
    ACL_ACTION_REJECT_BAD_NETWORK_TOS = 2;

    // Send ICMP Fragmentation Needed message 
    ACL_ACTION_REJECT_FRAGMENTATION_NEEDED = 3;

    // Send ICMP Host Prohibited message 
    ACL_ACTION_REJECT_HOST_PROHIBITED = 4;

    // Send ICMP Host Unknown message
    ACL_ACTION_REJECT_HOST_UNKNOWN = 5;

    // Send ICMP Host Unreachable message 
    ACL_ACTION_REJECT_HOST_UNREACHABLE = 6;

    // Send ICMP Network Prohibited message 
    ACL_ACTION_REJECT_NETWORK_PROHIBITED = 7;

    // Send ICMP Network Unknown message 
    ACL_ACTION_REJECT_NETWORK_UNKNOWN = 8;

    // Send ICMP Network Unreachable message 
    ACL_ACTION_REJECT_NETWORK_UNREACHABLE = 9;

    // Send ICMP Port Unreachable message 
    ACL_ACTION_REJECT_PORT_UNREACHABLE = 10;

    // Send ICMP Precedence Cutoff message 
    ACL_ACTION_REJECT_PRECEDENCE_CUTOFF = 11;

    // Send ICMP Precedence Violation message 
    ACL_ACTION_REJECT_PRECEDENCE_VIOLATION = 12;

    // Send ICMP Protocol Unreachable message 
    ACL_ACTION_REJECT_PROTOCOL_UNREACHABLE = 13;

    // Send ICMP Source Host Isolated message 
    ACL_ACTION_REJECT_SOURCE_HOST_ISOLATED = 14;

    // Send ICMP Source Route Failed message 
    ACL_ACTION_REJECT_SOURCE_ROUTE_FAILED = 15;

    // Send TCP Reset message 
    ACL_ACTION_REJECT_TCP_RESET = 16;
}

/* A void message */
message AccessListVoid {
    string void = 1;
}

/* 
 * Policer parameter for two color policer
 */

message AclPolicerTwoColor {

    // Bandwidth unit 
    AclPolicerRate bw_unit = 1;

    // Bandwidth rate 
    uint64 bandwidth = 2;

    // Burst unit 
    AclPolicerBurstSize burst_unit = 3;

    // Burst size 
    uint64 burst_size = 4;

    // Loss priority 
    AclLossPriority lp = 5;

    // Forwarding class. 
    string fc_string =  6;

    // Discard action 
    AclBooleanType discard = 7;
}

/* 
 * Policer parameter for single rate three color policer
 */
 
message AclPolicerSingleRateThreeColor {
   
    // Bandwidth unit 
    AclPolicerRate committed_rate_unit = 1;

    // Bandwidth rate 
    uint64 committed_rate = 2;

    // Burst unit 
    AclPolicerBurstSize committed_burst_unit = 3;

    // Burst size 
    uint64 committed_burst_size = 4;

    // Burst size 
    uint64 excess_burst_size = 5;

    // Burst unit 
    AclPolicerBurstSize excess_burst_unit = 6;

    // Discard action 
    AclBooleanType discard = 7;

    //Color mode
    AclColorModeType color_mode = 8;
}

/* 
 * Policer parameter for two rate three color policer
 */
 
message AclPolicerTwoRateThreeColor {

    // Bandwidth unit 
    AclPolicerRate committed_rate_unit = 1;

    // Bandwidth rate 
    uint64 committed_rate = 2;

    // Burst unit 
    AclPolicerBurstSize committed_burst_unit = 3;

    // Burst size 
    uint64 committed_burst_size = 4;

    // Bandwidth unit 
    AclPolicerRate excess_rate_unit = 5;

    // Bandwidth rate 
    uint64 excess_rate = 6;

    // Burst unit 
    AclPolicerBurstSize excess_burst_unit = 7;

    // Burst size 
    uint64 excess_burst_size = 8;

    // Discard action 
    AclBooleanType discard = 9;

    //Color mode
    AclColorModeType color_mode = 10;
}

/*
 * Heirarchical Policer parameters
 */
 
message AclPolicerHeirarchical {

    // Bandwidth unit 
    AclPolicerRate aggregate_rate_unit = 1;

    // Bandwidth rate 
    uint64 aggregate_rate = 2;

    // Burst unit 
    AclPolicerBurstSize aggregate_burst_size_unit = 3;

    // Burst size 
    uint64 aggregate_burst_size = 4;
   
    // Bandwidth unit 
    AclPolicerRate preminum_rate_unit = 5;
   
    // Bandwidth rate 
    uint64 premium_rate = 6;

    // Burst unit 
    AclPolicerBurstSize premium_burst_size_unit = 7;

    // Burst size 
    uint64 premium_burst_size = 8;

    // Discard action 
    AclBooleanType discard = 9;
}

/* 
 * Policer Parameter
 */
 
message AclPolicerParameter {
   oneof OneOf_PolicerParameter {

      // Two color 
      AclPolicerTwoColor two_color_parameter = 1;

      // Three color 
      AclPolicerSingleRateThreeColor sr_three_color_parameter = 2;

      // Three color 
      AclPolicerTwoRateThreeColor tr_three_color_parameter = 3;

      // Hierarchcical 
      AclPolicerHeirarchical hierarchical_parameter = 4;
    }
}

/* 
 * ACL Policer
 */
 
message AccessListPolicer {

    // Policer name 
    string policer_name = 1;

    // Policer type 
    AclPolicerType policer_type = 2;

    // Policer Flags 
    AclPolicerFlags policer_flag = 3;

    // Policer Paremeter 
    AclPolicerParameter policer_params = 4;
}

/* 
 * Destination Address match condition
 */
 
message AclMatchIpAddress {
 
    // address
    jnxBase.IpAddress addr = 1; 

    // Destination prefix length 
    uint32 prefix_len = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Port match condition
 */
 
message AclMatchPort {

    // Minimum port 
    int32 min = 1;

    // Maximum port 
    int32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Ip Precedence match
 */

message AclMatchIpPrecedence {

    // Minimum precedence
    Precedence min = 1;
   
    // Maximum precedence
    Precedence  max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;

}

/* 
 * DSCP (diffserv code point) match condition
 */
 
message AclMatchDscpCode {

    // Minimum Dscp code 
    uint32 min = 1;
 
    // Maximum Dscp code 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;

}

/* 
 * IP Protocol match condition
 */
 
message AclMatchProtocol {

    // Minimum Protocol number 
    uint32 min = 1;

    // Maximum Protocol number 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * ICMP type match condition
 */
 
message AclMatchIcmpType {

    // Minimum Icmp type 
    uint32 min = 1;

    // Maximum Icmp type 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * ICMP code match condition
 */
 
message AclMatchIcmpCode {

    // Minimum Icmp code 
    uint32 min = 1;

    // Maximum Icmp code 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * Packet length match condition
 */
 
message AclMatchPktLen {

    // Minimum Packet length 
    uint32 min = 1;

    // Maximum Packet length 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Fragment Flags
 */
 
enum AclFragmentFlags {

    // None 
    ACL_FRAGMENT_NONE = 0;

    // Dont fragment flag  
    ACL_DONT_FRAGMENT = 1;

    // Is fragment flag
    ACL_IS_FRAGMENT = 2;

    // First fragment flag 
    ACL_FIRST_FRAGMENT = 3;

    // More last fragment flag 
    ACL_LAST_FRAGMENT = 4;
}

/* 
 * Precedence 
 */
 
enum Precedence {

    // Routine precedence 
    ACL_PRECENCE_ROUTINE = 0;

    // Priority precedence 
    ACL_PRECENCE_PRIORITY = 1;

    // Immediate precedence 
    ACL_PRECENCE_IMMEDIATE = 2;

    // Flash precedence 
    ACL_PRECENCE_FLASH = 3;

    // Flash override precedence 
    ACL_PRECENCE_FLASH_OVERRIDE = 4;

    // Critical ecp precedence 
    ACL_PRECENCE_CRITICAL_ECP = 5;

    // Internet control precedence 
    ACL_PRECENCE_INTERNET_CONTROL = 6;

    // Network control precedence 
    ACL_PRECENCE_NET_CONTROL = 7;
}

/* 
 * TTL (Time to live) match condition for IPv4
 */
 
message AclMatchTtl {

    // Minimum Time to live 
    uint32 min = 1;

    // Maximum Time to live 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

message AclMatchFragmentOffset {

    // Fragment offset range start 
    uint32 min = 1;

    // Fragment offset range start 
    uint32 max = 2;
 
    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Police the matching packets
 */
 
message AclActionPolicer {

    // The policer 
    AccessListPolicer policer = 1;
}

/* 
 * Counter action
 */
 
message AclActionCounter {

    // Counter name (upto 64 characters) 
    string counter_name = 1;

}

/* 
 * Direct matching packets to a routing-instance
 */
 
message AclActionRoutingInstance {

    string rt_instance_name = 1;

}

/* 
 * ACL Entry operation
 */
 
enum AclEntryOperation {

    // Invalid ACE operation
    ACL_ENTRY_OPERATION_INVALID = 0;

    // Add a new ACE. 
    // Can be used with Add ACL, Change ACL, replace ACL API's  
    ACL_ENTRY_OPERATION_ADD = 1;

    // Delete a existing ace. 
    // Can be used with change ACL API 
    ACL_ENTRY_OPERATION_DELETE = 2;

    // Replace a existing ace. Must provide adjacency details to 
    // preserve the order of the ace. Can be used with Change ACL API  
    ACL_ENTRY_OPERATION_REPLACE = 3;
}

/* 
 * Adjacency Type which determines the ACE order in an ACL
 */
 
enum AclAdjacencyType {

    // For first ace 
    ACL_ADJACENCY_NONE = 0;

    // Add next to the given ace  
    ACL_ADJACENCY_AFTER = 1;

    // Add before the given ace 
    ACL_ADJACENCY_BEFORE = 2;
}

/* 
 * Adjacency details of ace placement
 */
 
message AclAdjacency {

    // Type of adjacency placement 
    AclAdjacencyType type = 1;

    // The previous or the next AC 
    string ace_name = 2;
}

/*
 * Ifl Index or name
 */
message AclMatchIflNameIndex {

    // Ifl index or name
    oneof AclEntryMatchIflNameFormat {

        // Ifl Name
        string ifl_name = 1;

        // Ifl Index
        uint32 ifl_index = 2;
    }
}

/*
 * Flex Offset range matches
 */

message AclMatchFlexOffset {

    // Minimum range value
    uint32 min = 1;

    // Maximum range value
    uint32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}


enum AclEntryMatchFlexStartOffest {

    // Invalid Flex match start offset
    ACL_FLEX_MATCH_OFFSET_INVALID = 0;

    // Layer-3 Flex match start offset
    ACL_FLEX_MATCH_OFFSET_LAYER_THREE = 1;

    // Layer-4 Flex match start offset
    ACL_FLEX_MATCH_OFFSET_LAYER_FOUR = 2;

    // Payload Flex match start offset
    ACL_FLEX_MATCH_OFFSET_PAYLOAD = 3;

}


message AclMatchFlexibleRange {

    // Flex match start offset
    AclEntryMatchFlexStartOffest start_offset = 1;

    // Flex match bit length (0 - 32)
    uint32 bit_length = 2;

    // Flex match bit offset (0 - 7)
    uint32 bit_offset = 3;

    // Flex match byte offset
    uint32 byte_offset = 4;

    // Flex match range value
    AclMatchFlexOffset range = 5;
}
  
message AclMatchFlexibleOffsetRange {

    oneof Oneof_AclEntryMatchFlexibleOffsetRange {

        AclMatchFlexibleRange flex_range_match = 2;
    }
}


message AclMatchFlexibleMask {

    // Flex match start offset
    AclEntryMatchFlexStartOffest start_offset = 1;

    // Flex match bit length (0 - 32)
    uint32 bit_length = 2;

    // Flex match bit offset (0 - 7)
    uint32 bit_offset = 3;

    // Flex match byte offset
    uint32 byte_offset = 4;

    // Flex match mask 
    uint32 mask = 5;

    // 32 Bit, Flex match value in hex format (0x12345678)
    string prefix_string = 6;
}

message AclMatchFlexibleOffsetMask {
   
    oneof Oneof_AclEntryMatchFlexibleOffsetMask {

        AclMatchFlexibleMask flex_mask_match = 2;
    }
}


/* 
 * An ACL Match 
 */

message AclEntryMatchInet {
    // List of Destination addresses 
    repeated AclMatchIpAddress match_dst_addrs = 1;
    
    // List of Source addresses 
    repeated AclMatchIpAddress match_src_addrs = 2;
    
    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 3;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 4;

    // List of Dscp code points 
    repeated AclMatchDscpCode match_dscp_code = 5;

    // List of Protocols 
    repeated AclMatchProtocol match_protocols = 6;
    
    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 7;
   
    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 8;
  
    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 9;

     // List of Ttl's 
     repeated AclMatchTtl match_ttl = 10;
 
     // Fragment flag 
     AclFragmentFlags fragment_flags = 11;

     // List of fragment offset range 
     repeated AclMatchFragmentOffset match_frag_offset = 12;

     // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
     repeated AclMatchIflNameIndex ifl_names = 13;

     // List of ip precedence
     repeated AclMatchIpPrecedence match_ip_precedence = 14; 

    // List of Addresses
    repeated AclMatchIpAddress match_addrs = 15;

    // List of Ports
    repeated AclMatchPort match_ports = 16;

    // List of Flex Ranges
    repeated AclMatchFlexibleOffsetRange match_flex_range = 17;

    //List of Flex Masks
    repeated AclMatchFlexibleOffsetMask match_flex_mask = 18; 
}
/* 
 * Terminating ACL Action
 */

message AclEntryInetTerminatingAction {
    oneof Oneof_AclEntryInetTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;
    
        // Discard the matching packets
        AclBooleanType action_discard = 2;
    
        // Reject the matching packets
        AclEntryActionRejectReason action_reject = 3;
    
        // Direct matching packets to a routing instance
        AclActionRoutingInstance action_rt_inst = 4;
    }
}

/* 
 * Non-terminating ACL Action
 */

message AclEntryInetNonTerminatingAction {

        // Count the matching packets
        AclActionCounter action_count = 1;
    
        // Log the matching packets
        AclBooleanType action_log = 2;
    
        // Syslog the matching packets
        AclBooleanType action_syslog = 3;
    
        // Police the matching packets.
        // Ensure that policer exists before it being used.
        AclActionPolicer action_policer = 4;
    
        // Sample
        AclBooleanType action_sample = 5;
    
        // Next Term
        AclBooleanType action_next_term = 6;
}

/* 
 * ACL Action
 */

message AclEntryInetAction {

    // List of non-terminating actions.
    AclEntryInetNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryInetTerminatingAction action_t = 2;
}

/* 
 * An Inet ACL entry
 */

message AclInetEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchInet matches = 4;

    // Actions 
    AclEntryInetAction actions = 5;
}

/* 
 * An ACL entry. It could be one of type of families.
 */
 
message AclEntry {
    oneof OneOf_AclEntry {

        // For Inet family
        AclInetEntry inet_entry = 1;
    }
}


/* 
 * AccessList types. 
 */
 
enum AccessListTypes {

    // Invalid ACL type
    ACL_TYPE_INVALID = 0;

    // Classic ACL type  
    ACL_TYPE_CLASSIC = 1;
}

/* 
 * AccessList Families. 
 */
 
enum AccessListFamilies {

    // Invalid
    ACL_FAMILY_INVALID = 0;

    // IPv4 family  
    ACL_FAMILY_INET = 1;

    // IPv6 family
    ACL_FAMILY_INET6 = 2;

    // Ethernet Switching family
    ACL_FAMILY_ES = 3;

    // VPLS family
    ACL_FAMILY_VPLS = 4;

    // MULTISERVICE family
    ACL_FAMILY_MULTISERVICE = 5;

    // CCC family
    ACL_FAMILY_CCC = 6;

    // MPLS family
    ACL_FAMILY_MPLS = 7;
}

/* 
 * Any proprietory flag to be enabled at the ACL level.
 */
 
enum AccessListFlags {

    // None 
    ACL_FLAGS_NONE = 0;
}

/* 
 * ACL
 */
 
message AccessList {

    // AccessList name
    string acl_name = 1;

    // AccessList type 
    AccessListTypes acl_type = 2;

    // AccessList family 
    AccessListFamilies acl_family = 3;

    // AccessList flag 
    AccessListFlags acl_flag = 4;

    // List of Destination addresses 
    repeated AclEntry ace_list = 5;
}

/* 
 * Direction in which an ACL is bound.
 */
 
enum AclBindDirection {

    ACL_BIND_DIRECTION_INVALID = 0;

    // Bind on ingress  
    ACL_BIND_DIRECTION_INPUT = 1;

    // Bind on egress  
    ACL_BIND_DIRECTION_OUTPUT = 2;
}

message AccessListCounter {

     AccessList acl = 1;

     string counter_name = 2;
}

message AccessListCounterBulk {

     AccessList acl = 1;

     uint32 starting_index = 2;
}

/*
 * Return values for the RPCs.
 */

enum AccessListReturnVal {
    
    // Success
    ACL_STATUS_EOK = 0;

    // The RPC was a NULL buffer
    ACL_STATUS_NULL_MESSAGE = 1;

    // Wrong input
    ACL_STATUS_EINVALID_MESSAGE = 2;

    // Server Internal error 
    ACL_STATUS_EINTERNAL = 3;

    // Operation not supported
    ACL_STATUS_EUNSUPPORTED_OP = 4;

    // Resource not available at server
    ACL_STATUS_NO_RESOURCE = 5;
 
    // Bulk Stats timeout
    ACL_STATUS_BS_TIMEOUT = 6;
}

message AccessListReturnStatus {

     AccessListReturnVal status = 1;
}

/* 
 * Return counter statistics
 */
 
message AccessListCounterVal {

    // Counter Name 
    string counter_name = 1;

    // Error status 
    AccessListReturnVal status = 2;

    // Byte count 
    uint64 bytes = 3;

    // Packet count 
    uint64 packets = 4;

}

/* 
 * The forwarding element entities to which the ACL can be bound.
 */

enum AccessListBindObjType {
    
    // Invalid
    ACL_BIND_OBJ_TYPE_INVALID = 0;
    
    // Interface 
    ACL_BIND_OBJ_TYPE_INTERFACE = 1;
}

/* 
 * Per forwarding element ACL binding
 */
 
message AccessListObjBind {

     // ACL
     AccessList acl = 1;

     // Binding object type
     AccessListBindObjType obj_type = 2;

     // Bind object name where the ACL is to be bound
     string bind_object = 3;

     // Bind direction 
     AclBindDirection bind_direction = 4;

     // Family on the bind object. Must match with the ACL family 
     AccessListFamilies bind_family = 5;

}

/* 
 * ACL Service APIs defines a set of simple RPCs to operate upon the various
 * components, viz. 
 *  - ACL
 *  - ACE
 *  - Policer
 *  - Attachment Points
 *  - Statistics.
 * 
 * Each of RPCs are named by concatenating the corresponding Acl object and the operation 
 * to be performed. This give a easy to understand semantics to the RPCs.
 * 
 */
  
service AclService {

        // Adds an ACL and returns the result.
	rpc AccessListAdd ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Delete an ACL from the system and return the result.
        // For successful delete to happen, the ACL should not be bound to any object.
	rpc AccessListDelete ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Changes an ACL based on the list of ACL entries provided, and returns the result.
        // It is advisable to use this API to for small incremental changes. For wholesale 
        // changes, it is recommended to use the 'Replace' version of the API.
	rpc AccessListChange ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Add a binding of an ACL with a bind object and return the result.
	rpc AccessListBindAdd ( AccessListObjBind ) returns ( AccessListReturnStatus ) {}

        // Deletes a binding of an ACL with a bind object and return the result.
        rpc AccessListBindDelete ( AccessListObjBind ) returns ( AccessListReturnStatus ) {}

        // Adds a policer and returns the result.
	rpc AccessListPolicerAdd ( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Changes a policer and returns the result.
	rpc AccessListPolicerReplace( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Deletes a policer and returns the result.
	rpc AccessListPolicerDelete( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Following are optimized command to let the server know to <br>
        // accumulate the Access List Entries and configure on when AccessListPileupEnd is received. <br>
        // For every AccessList RPC invocation, the entire ACL is applied to the system <br>
        // For application which wants to do batching for better performance, the AccessListPileupStart <br>
        // and AccessListPileupEnd will help achive that.
        
       rpc AccessListPileupStart(AccessListVoid) returns ( AccessListReturnStatus ) {}

       // Following are optimized command to let the server know to <br>
       // accumulate the ace_list and configure on when AccessListPileupEnd is received. <br>
       // For every AccessList RPC invocation, the entire ACL is applied to the system <br>
       // For application which wants to do batching for better performance, the AccessListPileupStart <br>
       // and AccessListPileupEnd will help achive that.

       rpc AccessListPileupEnd (AccessListVoid) returns ( AccessListReturnStatus ) {}
   
        // Few points to note with this API. 
        // The call is going to be blocking for worst case of 10 seconds which is non configurable.
        // The counter name is expected to be fully resolved. For eg. for term specific policer counter
        // it is expected to be passed to full counter name.

        rpc AccessListCounterGet ( AccessListCounter ) returns ( AccessListCounterVal ) {}

        rpc AccessListPolicerCounterGet ( AccessListCounter ) returns ( AccessListCounterVal ) {}

        // Clears a particular counter whose fully qualified name is provided,  associated with an ACL.
        // Few points to note with this API. Currently only 1 counter get is supported.
        // The counter name is expected to be fully resolved. For eg. for term specific policer counter
        // it is expected to be passed to full counter name.
    
	rpc AccessListCounterClear ( AccessListCounter )  returns ( AccessListReturnStatus ) {}

        // Get all the counters associated with an ACL.
        // Each call to this API will return 10 counters from the starting_index specified in AccessListCounterBulk message.
        // The client is expected to run this API in loop which should stop in either one of the following condition:
	//     a. The targeted number of counters are retrieved.
        //     b. An error is returned.
        //     c. The API returns less than 10 counters.
        
        rpc AccessListCounterBulkGet( AccessListCounterBulk ) returns ( stream AccessListCounterVal ) {}

        // Get all the policer counters associated with an ACL.
        // Each call to this API will return 10 counters from the starting_index specified in AccessListCounterBulk message.
        // The client is expected to run this API in loop which should stop in either one of the following condition:
	//     a. The targeted number of counters are retrieved.
        //     b. An error is returned.
        //     c. The API returns less than 10 counters.
        
        rpc AccessListPolicerCounterBulkGet( AccessListCounterBulk ) returns ( stream AccessListCounterVal ) {}
}
